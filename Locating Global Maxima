# Import necessary Libraries
import random, numpy, math

def f(x, y, z):
  f = math.exp(-y**2)*math.cos(77*y) - math.sin(43*x) + 0.5*z**2*math.exp(math.sin(73*z)) + 0.1*(x**2+y**2+z**2) + math.cos(73*math.sin(z)) - math.cos(71*x) - math.sin(73*y)
  return f # Defines the function being used

# Store Empty Array for Maximum Function Found
max_f = []

# Creates a loop for multiple runs to have more algorithms
for j in range(100):

# uniform distribution between -1 and 1 for x, y and z values
  xbest2 = random.uniform(-1, 1)
  ybest2 = random.uniform(-1, 1)
  zbest2 = random.uniform(-1, 1)
  fbest2 = f(xbest2, ybest2, zbest2)

# Takes x amount of steps to locate maxima
  steps = 1000000
  for i in range(steps):
    # uses the starting point previously randomised and adds a random fluctuation with a normal distribution of mean 0 and SD 0.1
    xnew2 = xbest2 + random.gauss(0, 0.1) # Normal dist
    ynew2 = ybest2 + random.gauss(0, 0.1)
    znew2 = zbest2 + random.gauss(0, 0.1)
    fnew2 = f(xnew2, ynew2, znew2)

# If the random fluctuation puts the values of x, y and z outside of it's prespecified range the algorithm will ignore this maximum value
    if -1 <= xnew2 <= 1 and -1 <= ynew2 <= 1 and -1 <= znew2 <= 1:
     if fnew2 > fbest2:
        fbest2 = fnew2
        xbest2 = xnew2
        ybest2 = ynew2
        zbest2 = znew2
        max_f.append(fbest2) # if new function is > old function it will append max_f to store this new maxima

     else:
      xbest2 = xbest2
      ybest2 = ybest2
      fbest2 = fbest2
      zbest2 = zbest2

# Prints out the best f(x,y,z) for each run and also the maxima f(x,y,z) for ease of analysis
#  print('x= ', xbest2, 'y= ', ybest2, 'z= ', zbest2, 'f= ',fbest2 )
print('Max_f= ', max(max_f))
